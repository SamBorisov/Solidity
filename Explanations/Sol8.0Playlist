Notes from: 
https://www.youtube.com/playlist?list=PLO5VPQH6OWdVQwpQfw9rZ67O6Pjfo6q-p
https://solidity-by-example.org/

Tornado cash hack - with create the address is calculated by deployer address and nonce - if the was 1st deployed contract then it is 0. Once a user calls self-destruct to a contract then the nonce of this contract won’t count so if he had 1 deployed contract and call self-destruct the nonce will be still 0. 
He proposed a nice contract with address that got approved for the main contract with delegate call, then he deleted this contract and deployed new one with bad code with the same address, that way he managed to hack the contracts!
   How to prevent?
- Carefully choose addresses of proposes and to who they are
- Avoid contracts with self-destruct
- Add event listener to the contract if self-destruct is called and if so, update the main contract to not work with this address
- Avoid delegate calls 


:
Constants safe gas (cost less then non constants), also immunatiable
We can log things with custom error (msg sender…)
Assert (num == 123) (if not it will revert) 
If function returns multiple things we can capture them with:
(uint x, bool b) = returnMany()
(, bool b) = returnMany() // If we don’t need the 1st one (still need the comma)
CREATE2 - able to predict contract address
^Array- when you delete element the length if the array stays the same and the element is 0, If you want to remove it from the array you need to shift all other elements to the left from it and them pop the last element, another gas efficient  way is to just replace the last element this this one and then pop (but it does not safe the order) 
^we can make test function and check after every action with assert! 
^ Mapping - we can delete elements (when we delete it is resented to default value)
If we want to interact with all of the mappings, we need array to save them and another mapping bool to keep in track if they are already in the array!
^delete struct is reseting it’s values	(or value we chose)
When interaction with storage keywords it changes the value of the structure 
^ delete enum is resting to the 1st item of the enum, we can set statuses by giving number from 0 to n and change the enum.
^Storage - modify blockchain
^Memory - store until function ends 
^Calldata - store as read-only (not modifiable) until function end (gas efficient)
^If we access the an array and need to modify a lot of times it’s better to make a storage reference and to update the reference, but if we do it only 1-2 times it’s better to do it directly
^ view function safe more gas declared as Storage , cuz they don’t make copy
^events even if they don’t change anything inside the contract they put information into the blockchain and a function with event is transactional
^Order of inheritance - from most vase-like to derived
^Constructors cannot be calldata
^Inheritance - is A, B , constructor(_txtB, _txtA) B(‘asfnsaf’) A(‘kdjfkdf’), it will be executed always as how it is inherently, no matter order of the constructor 
^ when using ‘super’ keyword for parents it will call all parents if we have more then once
^ when overriding a function, we can still call this function inside as the original logic
^we can call external functions with ‘this.functionName’ but it costs a lot of gas!
^receive - is executed when data is empty , if we have data the fallback will be executed , if we have both payable 
Receive does not trigger with data and should be always payable
Fallback triggers only with data ( if we put data and ETH, but is is not payable , I will get an error) , but only with data works if not payable
Both are only able to be external 
^sent ETH - contract can receive from constructor payable or receive/fallback function, or payable function overall
Give ETH from contract - 
1 - _to.trasnfer(_value) - revert if it fails
2 - _to.send(value) - returns a bool if it went or not, we can do it like this to ensure:
bool sent = _to.send(_value);
require(sent, ”send failed”);
3 - sents all the gas (unlike others who send 2300 both)
(bool success, ) = _to.call{value: _value}(“”);
require(success, ”call failed”);
^Delegate Calls - When you perform a delegate call in Solidity, you're essentially executing code from another contract as if it were a part of the calling contract. This means that the code being executed has access to the state variables and storage of the calling contract.
^When using Library we can say - using Lib for uint, and then call nameUnti.funcLub
^abi.ecnode - makes data into bytes
Abi.encodePacked - make to bytes and compresses data: If we have 2 strings , 1st ends with ‘a’ and use again same function but delete the ‘a’ from the 1st and add a in front of the 2nd, it will create the same output (hash problem), arrange so no dynamic inputs are next to eachother (string to string / uint to uint…)
^Recover - sign msg -> hash msg, getEthSignedMessageHash, recover (with address, sig, EthSignedMsgHash, split the sign r s v (assembly) 
^selfDestruct sends forced ETH to another contract (no receive function)
^Data return (msg.data) -  1st 4 bytes 0x12345678 - name of the function made by:
bytes4(keccack256(bytes(_func)));
Then rest of the data is the passed parameters 
^we can create a custom simple Interface with only the function with need (for example if we need only trasnferFrom, we can create interface with only this function)
^Create 2 , add salt bytes - new Contract {salt: bytes32(_salt)}
^to get the address:
Bytes32 hash = kecack256(abi.encodePacked(bytes1(0xff), address(this), _salt , keccack256(bytecode)
Return address(uint160(uint(hash)));
^MultiCall - we can call multiple functions  from other contracts , by knowing the address and the data of the function (encodeWithSelector) / encodeWithSignature
^DelegateMutiCall - if we use msg.sender with normal multi call it will take the address of contract not user. (Needs the contract of Deletacall to me inported in the contract in functions)
Dangerous - if we use parameter like msg.value and we use mutiDelegateCall and type the input of a function multiple times, it will use the msg.value for the 3 functions and give triple rewards.
^Gas Golf -     -  use calldata
-  Load state variable in memory (if we call it multiple times) directly talking with state variables is expensive 
- short circuit - to make if (false) -> to not do other code, if we have more the one thing to check ,to not calculate all then check, but then the 1st one is false others to be ignored 
- loop increment - ++i is better than  i += i ;
- Cashing the lengths of state variable: uint len = nums.lenght; (not use num.lenght every time in a loop and load it)
- Load array elements - uint num = num[i], then use num in the if statement 
^AMM - demand supply - liquidity pools give tokens and the price of the mutilation of the tokens should be a constant x * y = k, each time there is a token that people by more of , it will cost more ‘other’ tokens to buy.
AMM Swap tokens - dy = YdX / x + dx
^We don’t need to declare variable if it is in the function as returns(…)
^BitWise Operators with numbers
- and = x & y
- Or = x  | y
- Xor = x ^ y
- Not = ~x (use uint8 for small operations)
- ShiftLeft = x << bits
- ShiftRight = x >> bits
- Get last N bits = x % (1 << n);
^Encode data:
- abi.encodeWithSingnature(“trasfer(address,uint256)”, to amount);
Make sure that there are no extra spaces or anything to the function uint256, not only uint.  If we make type the code will still compile.
- Abi.encodeWithSelector(IERC20.transfer.selector, to , amount)
With encode selector if we have a typo it won’t compile, but if we give wrong inputs of the function or missing inputs, it will compile, we can pass the wrong datatype.
- Abi.encodeCall(IERC20.transfer, (to, amount))
Using call , check both function name and inputs lengths, type
!!!All this encoding Returns the same data!
- Test Function - 
Function test (address _contract, bytes calldata data) external {
	(bool ok,) = _contract.call(data);
	require(ok, “call failed”);
This function is to call the function we encoded with the data and address of the contract we wanna call!
^ Upgradable contract:
- Problem, if we upgrade with func to another contract and the storage is different (the position or there are missing things in the storage on the upgraded contract), then we could be bug so functions does not execute well and type in the wrong way! (Slots for storage problem)
We use here fallback/recieve function to call implementation contract like:
(Bool ok, bytes memory res) = addressImplement.delegatecall(msg.data)
Require (ok , “failed”)
Also fallback function does not return any data!
- The right way is the use minimal proxy from Openzeppelin with assembly code that loads to memory slot 1 the data from 0 to calldatasize/retrundatasize and we can return it, that way our functions do write in the storage of the contract
Code:
assembly {
            // Copy msg.data. We take full control of memory in this inline assembly
            // block because it will not return to Solidity code. We overwrite the
            // Solidity scratch pad at memory position 0.

            // calldatacopy(t, f, s) - copy s bytes from calldata at position f to mem at position t
            // calldatasize() - size of call data in bytes
            calldatacopy(0, 0, calldatasize())

            // Call the implementation.
            // out and outsize are 0 because we don't know the size yet.

            // delegatecall(g, a, in, insize, out, outsize) -
            // - call contract at address a
            // - with input mem[in…(in+insize))
            // - providing g gas
            // - and output area mem[out…(out+outsize))
            // - returning 0 on error (eg. out of gas) and 1 on success
            let result :=
                delegatecall(gas(), _implementation, 0, calldatasize(), 0, 0)

            // Copy the returned data.
            // returndatacopy(t, f, s) - copy s bytes from returndata at position f to mem at position t
            // returndatasize() - size of the last returndata
            returndatacopy(0, 0, returndatasize())

            switch result
            // delegatecall returns 0 on error.
            case 0 {
                // revert(p, s) - end execution, revert state changes, return data mem[p…(p+s))
                revert(0, returndatasize())
            }
            default {
                // return(p, s) - end execution, return data mem[p…(p+s))
                return(0, returndatasize())
            }
^Swot storage:
We can also save a var to a specific slot by:
Bytes32 public constant VAR_SLOT = bytes32(
	uint(keccack256(“eip1967.proxy.implementation”)) - 1 );
(Minus one to be be difficult to predict the hash)
All functions / variables should be private, forward all calls to fallback
We need to write get function to get the item for the storage
When me make modifiers and check something in that storage it should be handled with view function

^Check if address is contract
requite(address.code.length >0 ,”not a contract”);
^ Unchecked for overflowed & underflows saves gas
Code inside unchecked could be multiple lines
^Assembly:
Cannot use >= / <= , use gt (greater than only but not equal, remove number -1 to have same logic as equal.
We can sift bits by  shl - shift left or shr -  shift right,
Type numbers as 0x…  decimal 
We use := to assign to value
We can use the operator ‘or’ instead of add
^Fallbacks: 
in 0.8 fallbacks can take inputs as bytes and return outputs as bytes
We can create  proxy without assembly 
But we can still cannot return data with receive function!

https://github.com/t4sk/hello-foundry

^^^ Foundry Test:
1 - name the file - Contract.t.sol
2 - Import the Test and the contract we wanna test
3 - make “setUp”  function that execute EVERY time before each function and deploys a new contract 
4 - make function with name “testFuncName” / “testLogic”
5 - if you expect function to give error - “testFailName” 
6 - other way to handle error is “vm.expectRevert()” - no need to name function with Fail
- There is verbosity option -v to -vvvvv , each giving more information 
- Gas info —gas-report 
- In foundry.toml file you can specify the sol version - solc_version = “0.8.17”, compile & build will fail if we use different version
- Importing - get lib with forge install …., then import autoaticly from library by /libName/Contract.sol. 
- Remapping , when installing npm packages , we need to make “remapping.txt” file and type - @openzeppelin/=node_modules/@openzeppelin
- Importing openzeppeling with node npm i openzeppelin, import”@opeznzeppelin/contracts/contrac.sol”
- Fomrtaing text use command - forge fmt
- We can console log things - import “forge-std/console.log”; , make sure you remove before deploying contracts. Use -vv at test to log, we can log in the test too! To log “int” we need special function!
- Call function from different address - vm.startPrank(address(1)) to stop using this address - vm.stopPrank(): To use only for one call we use vm.prank(address(1)) If we don’t specify address it will be executed from the contract address
- To make test with error you can name it - testFail… or add in the code - vm.expectRevert() We can add the msg with require  - vm.expectRevert(bytes(“This is test error”)); err.throwError(); For custom - vm.expectRevert(Error.CumstomError.selector);   err.throwCustumError();
- We can label - assertEq(uint256(1), uint256(1), “test 1”); - it will show as test one fails if there are multiple assertEqs.
- Events - 1st type the data you expect, then emit the event and then call the function you expect to emit the event with the data 
- Time - vm.wrap - set the block timestamp  in the future  vm.roll - set block number skip(number) - increment current timestamp rewind(number) - decrement current timestamp
- Sending ETH - deal(address(1),100); - sets balance of address (no matter how big it was)
	assert(address(1).balance, 100);
	^ hoax - deal + prank, sets up prank and set balance 
	hoax(address(1), 123)
	_send(123);   - function that sends ETH to contract to test if it from address 1 prank
- Signature -  function testSignature() public {
-      uint256 privateKey = 123;
-         // Computes the address for a given private key.
-         address alice = vm.addr(privateKey);
- 
-         // Test valid signature
-         bytes32 messageHash = keccak256("Signed by Alice");
- 
-         (uint8 v, bytes32 r, bytes32 s) = vm.sign(privateKey, messageHash);
-         address signer = ecrecover(messageHash, v, r, s);
- 
-         assertEq(signer, alice);
- 
-         // Test invalid message
-         bytes32 invalidHash = keccak256("Not signed by Alice");
-         signer = ecrecover(invalidHash, v, r, s);
- 
-         assertTrue(signer != alice);
-     }
- Test for ERC20Permit + fee 
	https://github.com/t4sk/hello-foundry/blob/main/test/app/GaslessTokenTransfer.t.sol
- Fork:
	We can fork from chain with setting a FROK_URL= provider , and then running command:
	forge test —fork-url $FROK_URL —match-path test/NameTest.t.sol
- Fuzz testing: Testing contract with random inputs 
	We can create a helper function with logic and then 
	put an input of a test function (uint256 x)
	mv.assume (x > 0); // we can set to be greater then a value
	x = bound(x, 1, 10); // or between values
	uint I = contract.func(x);
	assertEq(I , helperFunc(x));
	Returns (runs: 256(how many inputs), u: 13123(average gas ‘total gas/times it run), ~: 13424 (median gas , the gas of in the half)
- Invariant - a random input is in function and this function is Called multiple times + the functions are randomly executed by order, after functions are called some checks will run and if they all pass then the invariant test will pass. Calls functions in contract randomly.
- Handler based testing - make a contract , make inputs in function with bound (…) and then call the actual contract. After that make Invariant test for the contract with bound inputs that calls the contract we wanna test. ^targetContract(…)
	^targetSelectors(…
- FFI - run document 
 



             
 
