_______________ Sorting _______________

1 - Bubble Sort
Bubble sort is a simple yet effective sorting algorithm that can be seamlessly implemented in Solidity.
Sorts it in ascending order, and returns the sorted array.


function bubbleSort(uint[] memory arr) public pure returns (uint[] memory) {
 uint n = arr.length;
    for (uint i = 0; i < n - 1; i++) {
        for (uint j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
            (arr[j], arr[j + 1]) = (arr[j + 1], arr[j]);
            }
        }
    }
 return arr;
}

_Limitations: 
Bubble sort is generally inefficient for large datasets due to its quadratic time complexity.
!Data type: Smaller data types (e.g., uint8) will have less memory overhead than larger ones (e.g., uint256).


2 - Quick Sort
Quick sort is a popular sorting algorithm that uses a divide-and-conquer strategy to sort elements efficiently.
Sorts it in ascending order, and returns the sorted array.

function quickSort(uint[] memory arr) public pure returns (uint[] memory) {
    if (arr.length <= 1) return arr;
    uint pivot = arr[arr.length / 2];
    uint[] memory left;
    uint[] memory right;
    
    for (uint i = 0; i < arr.length; i++) {
        if (arr[i] < pivot) {
        left.push(arr[i]);
        }
        if (arr[i] > pivot) {
        right.push(arr[i]);
        }
    }
 
 return concat(quickSort(left), pivot, quickSort(right));
}

_Limitations:
Large Arrays: Sorting large arrays might result in exceeding the block gas limit, making the transaction fail.
Recursive Depth: Solidity has a limit on the depth of recursion, which can cause issues if the array size is very large.
Concatenate function is not defined by default, so it should be implemented separately.


3 - Merge Sort
Merge sort is a stable sorting algorithm that divides the array into two halves, sorts them, and then merges them back together.
Sorts it in ascending order, and returns the sorted array.

function mergeSort(uint[] memory arr) public pure returns (uint[] memory) {
 if (arr.length <= 1) return arr;
 uint middle = arr.length / 2;
 uint[] memory left = new uint[](middle);
 uint[] memory right = new uint[](arr.length - middle);
 
    for (uint i = 0; i < middle; i++) {
    left[i] = arr[i];
    }
    for (uint i = middle; i < arr.length; i++) {
    right[i - middle] = arr[i];
    }
 
 return merge(mergeSort(left), mergeSort(right));
}

_Limitations:
Large Arrays: Sorting large arrays might result in exceeding the block gas limit, making the transaction fail.
Memory Allocation: Merge sort requires additional memory for the left and right arrays, which can be costly for large arrays.
Merge function is not defined by default, so it should be implemented separately.