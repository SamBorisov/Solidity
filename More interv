100 :Create a function to determine if another address is a contract or a regular address

                                   function isHuman(address addr) external {
                                      uint256 codeLength;

                                      assembly {codeLength := extcodesize(addr)}
                                      return codeLength == 0 ? true : false;
                                    }
                                  }
                                  
                                  
99:How to declare assembly code?
assembly {}

What are the 2 kind of assembly in Solidity?
Functional and instructional. Functional uses functions, whereas instructional is a raw series of opcodes. Most people use the functional style.


97:How to generate a random integer in Solidity?
We can leverage the block.timestamp and block.difficulty as a source of randomness, and use the keccak256() hashing function:

uint(keccak256(abi.encodePacked(block.timestamp, block.difficulty)))


How to produce a hash of multiple values in Solidity?

keccak256(abi.encodePacked(a, b, c))

95/4.What is a re-entrancy attack?
A re-entrancy attack happen when a contract A calls a contract B which call back the calling function on contract A to perform some malicious effect. Example with a DAO-like attack:

              contract A {
                //...
                function pay(address payable to, uint amount) external {
                  if(amount <= balances[msg.sender]) {
                    B(to).badFunction().send(amount);
                    balances[msg.sender] -= amount;
                }
              }


              contract B {
                address
                function badFunction(address payable to) external {
                  ContractA(msg.sender).pay();
                }
              }

How to prevent against a re-entrancy attack?

          Solution 1: Decrease balances / do other state variable update BEFORE calling the other contract.
          Solution 2: Put in place re-entrancy guard with a variable that knows when a call is the second in the stack
          Solution 3: Limit the gas available to the called contract. If using transfer(), this is done automatically:
          
          
93:91. What is a library in Solidity?
A library is a piece of code that be re-used by other smart contracts. There are 2 types of libraries:

deployed
embedded

When is a library embedded vs deployed?

                        //Embedded (function is internal)
                        library Lib {  
                          function add(uint a, uint b) pure internal returns(uint) {
                            return a + b;
                          }
                        }

                        //Deployed (function is public)
                        library Lib {  
                          function add(uint a, uint b) pure public returns(uint) {
                            return a + b;
                          }
                        }
                        
                        
 Give an example of how to use a library in a smart contract
 
                                  library Lib {  
                                    function add(uint a, uint b) pure internal returns(uint) {
                                      return a + b;
                                    }
                                  }

                                  contract A {
                                    using Lib for uint;

                                    function add(uint a, uint b) pure external returns(uint) {
                                      return a.add(b);
                                    }
                                  }
                                  
                                  
 90. Which Solidity function would you use to verify a signature?
ecrecover().


89. Is it possible to send a transaction without requiring users to pay gas?

Yes. You would ask users to first sign a message on the frontend. 
Then the message and signature would be sent to a centralized backend (your app, off-chain) 
that would create a transaction and embed the payload (message + signature) into it.
That means that gas fees will be covered by the wallet of the app, instead of the user wallet. 
On-chain, a smart contract will verify the validity of the signature and perform on operation on behalf of the user.


87. What is the ABIEncoderV2 pragma statement?
This is an pragma statement is used to enable experimental features not yet enabled in standard Solidity. For example it enables to return a struct from a function called externally, which is not possible in standard Solidity yet (0.5.x).

88. Is it safe to use the ABIEncoderV2 pragma statement in production?
No. It should only be used in development, not in production.
